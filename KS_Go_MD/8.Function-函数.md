# 8.Function 函数
### 函数是基本的代码块，用于执行一个任务。
### Go语言最少有个 main() 函数。
### 可以通过函数来划分不同功能，逻辑上每个函数执行的是制定的任务。
### 函数声明告诉了编译器函3件事：1.函数的名称；2.参数；3.返回类型。

## 32函数的声明 Func_Decl (Function Declaration)
## 函数的调用
## 33形式参数和实际参数 Func_Parameter_Argment
## 34可变参数 Func_Varargs (Variadic Parameter)
## 参数传递 Func_Param_Pass (Parameter Passing)
## 值传递 Func_Varargs_Value_Pass (Variable number of Arguments Value Passing)
## 引用传递 Func_Varargs_Ref_Pass (Reference Passing)
## 函数变量的作用域 Func_Var_Scope (Function Variables Scope)
## 递归函数 Func_Recur (Function Recursive)
## Defer延迟函数执行 Func_Defer (Function Defer)


# 函数的声明 Func_Decl (Function Declaration)
### Go语言函数定义格式如下：
```go
func function_name( [parameter list] ) [ return_type ] {
	函数体
}
```
## Go语言允许有函数有以下5种声明：
### 无参数，无返回值，的函数
### 有1个参数，的函数
### 有2个参数，的函数
### 有1个返回值，的函数
### 有多个返回值，的函数


# 无参数，无返回值，的函数
// 无参数，无返回值，的函数
func printinfo() {
	fmt.Println("printinfo")
}


# 有1个参数，的函数
// 有1个参数，的函数
func myprint(msg string) {
	fmt.Println(msg)
}


# 有2个参数，的函数
// 有2个参数，的函数
// 有1个返回值，的函数
func add(a int, b int) int {
	c := a + b
	return c
}


# 有1个返回值，的函数
// 有2个参数，的函数
// 有1个返回值，的函数
func add(a int, b int) int {
	c := a + b
	return c
}


# 有多个返回值，的函数
// 有多个返回值，的函数
func swap(x string, y string) (string, string) {
	return y, x
}

# 函数的调用
```go
	// 调用无参数，无返回值，的函数
	printinfo()

	// 调用有参数的函数，我们就需要按接收函数的参数类型来传递
	myprint("Xaiat.com")

	// 调用有返回值的函数，我们就需要按接收函数的返回值类型来接收
	c := add(1, 2)
	myprintnum(c)

	// 调用有多个返回值的函数
	x, y := swap("Xaiat", ".com")
	fmt.Println(x, y)

}
```

# 形式参数和实际参数 Parameter_Argment
### 形参：Parameter，函数声明中用来占位的参数名，“参数占位符”更容易理解。
### 实参：Argument，函数调用时候真实传入的参数。

# 可变参数 Func_Varargs (Variadic Parameter)
### 一个函数的参数类型确定，但是数量不确定，就可以使用可变参数
### 如果一个函数的参数是可变参数，同时还有其他的参数，可变参数要放在列表的最后
### 一个函数的参数列表中最多只能有一个可变参数
```go
package main

import "fmt"

// arg ...int 告诉 Go 这个函数接收不定数量的参数，类型全部是 int
func main() {
	// 调用函数时，可以传递任意数量的参数
	getSum("Xaiat", 1, 2, 3, 4, 5, 6, 7, 8, 100)
}

func getSum(msg string, nums ...int) {
	sum := 0

	for i := 0; i < len(nums); i++ {
		fmt.Println(nums[i])
		// sum = sum + nums[i], sum += nums[i] 是一样的
		sum += nums[i]
	}
	fmt.Println("msg:", msg)
	fmt.Println("sum:", sum)

}
```

# 参数传递 Func_Varargs (Parameter Passing)
### 按照数据的存储特点来划分：参数传递可以分为“值专递”和“引用传递”
### 值类型的数据：操作的数据本身、int、string、bool、float64、array...
### 引用类型的数据：操作的是数据的地址 slice(切片)、map(集合)、chan(通道)...

# 值传递 Func_Varargs_Value_Pass (Variable number of Arguments Value Passing)
```go
package main

import "fmt"

func main() {
	// 1.值传递
	// arr2 的数据是 从 arr 复制来的，所以是不同的空间
	// 修改 arr2 并不会影响 arr
	// 值传递的核心：传递的是数据的副本，修改数据，对于原始的数据没有影响
	// 值类型的数据，默认都是值传递：基础类型、array数组、struct结构体
	// 定义一个数组 [个数]类型
	arr := [4]int{1, 2, 3, 4}
	// 用[]中括号打印出来的都是数组的值
	fmt.Println(arr)
	// 传递：执行了拷贝arr动作
	update(arr)
	fmt.Println("调用修改后的数据：", arr)
	// 2.引用传递
}

func update(arr2 [4]int) {
	fmt.Println("arr2接收的数据：", arr2)
	// 数组里的值都是从0开始的
	arr2[0] = 100
	fmt.Println("arr2修改后的数据：", arr2)
}
```

# 引用传递 Func_Varargs_Ref_Pass (Reference Passing)
```go
package main

import "fmt"

// 按照数据的存储特点来划分：参数传递可以分为“值专递”和“引用传递”
// 值类型的数据：操作的数据本身、int、string、bool、float64、array...
// 引用类型的数据：操作的是数据的地址 slice(切片)、map(集合)、chan(通道)...

// 参数传递，首先有2个数组，一个是arr，一个是arr2，arr2的数据是从arr复制来的，所以是不同的空间，修改arr2并不会影响arr
// 引用传递和值传递是函数中的重点内容
// 值传递的核心：传递的是数据的副本，修改数据，对于原始的数据没有影响
// 引用传递的核心：传递的是数据的地址，修改数据，对于原始的数据也会有影响
// 引用传递和值传递的区别：引用传递传递的是数据的地址，修改数据，对于原始的数据也会有影响
// 引用传递的数据类型：引用类型的数据，默认都是引用传递：slice（切片）、map（集合）、chan（通道）
func main() {

	// 切片，是一个可以扩容的数组
	// 切片是引用类型的数据，默认都是引用传递：slice（切片）、map（集合）、chan（通道）
	// 数组传递参数进来是两个值，一个是数组的地址，一个是数组的长度
	// 而切片操作的始终是同一个空间，所以修改切片的值，会影响原始的数据
	s1 := []int{1, 2, 3, 4}
	// 顺序1.值传递
	fmt.Print("默认的数据：", s1)
	// 顺序2.引用传递
	// 传入的参数是引用类型的数据，是地址，所以s1和s2指向的是同一个地址
	update2(s1)
	// 顺序5.引用传递
	fmt.Print("调用后的数据：", s1)
}

func update2(s2 []int) {
	// 顺序3.引用传递
	fmt.Print("传递的数据：", s2)
	s2[0] = 100
	// 顺序4.引用传递
	fmt.Print("修改后的数据：", s2)
}
```

# 函数变量的作用域 Func_Var_Scope (Function Variables Scope)
### 作用域：变量可以使用的范围
## 变量分为：局部变量 和 全局变量
### 局部变量：函数内部定于的变量，叫做局部变量，只能在函数内部使用
### 全局变量：函数外部定于的变量，叫做全局变量，可以在函数内部和外部使用
```go
package main

import "fmt"

// 全局变量
// 定义变量的时候，要思考这个变量是在哪里使用，如果是全局变量，就定义在函数外部；如果是局部变量，就定义在函数内部
var num int = 100

func main() {
	/*
		// 函数体内的局部变量
		temp := 100

		// if语句、for语句定义的一次性变量都是局部变量，只能在语句内使用
		if b := 1; b <= 10 {
			// 语句内的局部变量
			temp := 50
			fmt.Println(temp) // 50，局部变量，遵循就近原则
			fmt.Println(b)    // 1
		}
		fmt.Println(temp) // 100
	*/

	num := 20
	// 无论是全局变量还是局部变量，都是找最近的变量去打印
	fmt.Println(num) // 20

	f1()
	f2()
	f3()
}

func f1() {
	num := 30
	// 无论是全局变量还是局部变量，都是找最近的变量去打印
	fmt.Println(num) // 30
}

func f2() {
	num := 40
	// fmt.Println(a) // 不能使用其他函数中定义的变量
	// 无论是全局变量还是局部变量，都是找最近的变量去打印
	fmt.Println(num) // 40
}

func f3() {
	// 无论是全局变量还是局部变量，都是找最近的变量去打印
	fmt.Println(num) // 100
}
```

# 递归函数 Func_Recur (Function Recursive)
### 定义：一个函数自己调用自己，就叫做递归函数
### 注意：递归函数需要有一个出口，逐渐向出口靠近，没有出口就会形成死循环
```
package main

import "fmt"

// 递归函数 Func_Recur (Function Recursive)
// 定义：一个函数自己调用自己，就叫做递归函数
// 注意：递归函数需要有一个出口，逐渐向出口靠近，没有出口就会形成死循环

// 想要做一个求和：1，2，3，4，5
// getsum(5)
//   getsum(4)+5
//	   getsum(3)+4
//       getsum(2)+3
//		   getsum(1)+1
//			 getsum(1)就是1本身

func main() {

	sum := getSum(5)
	fmt.Println(sum)
}

// 5
// getSum(5)=getSum(4)+5
// gerSum(4)+5=gerSum(3)+4+5
// gerSum(3)+4+5=gerSum(2)+3+4+5
// gerSum(2)+3+4+5=gerSum(1)+2+3+4+5
// gerSum(1)+2+3+4+5=1+2+3+4+5=15

func getSum(n int) int {

	if n == 1 {
		return 1
	}

	return getSum(n-1) + n
}

/*
这段代码定义了一个名为 getSum 的递归函数，它的目的是计算从 1 到 n 的所有整数的和。递归是一种编程技术，函数在执行过程中调用自身。

在 getSum 函数中，我们首先检查参数 n 是否为 1。如果是，函数就返回 1，这是递归的基本情况。如果 n 不是 1，函数就返回 getSum(n-1) + n。
这是递归的递归情况，函数调用自身，但是每次调用时 n 的值都减少 1，这样就可以逐渐接近基本情况。

例如，如果我们调用 getSum(5)，函数将执行以下操作：

检查 5 是否为 1。因为 5 不是 1，所以函数返回 getSum(4) + 5。
为了计算 getSum(4)，函数再次调用自身，这次 n 的值为 4。函数返回 getSum(3) + 4。
这个过程会一直持续下去，直到 n 的值为 1。此时，函数返回 1。
然后，所有的函数调用开始返回，每次返回时都会加上 n 的当前值。所以，最终的结果是 1 + 2 + 3 + 4 + 5 = 15。
这就是递归函数的工作原理。它们可以非常强大，但也需要小心使用，因为如果没有正确的基本情况或者递归情况，它们可能会导致无限循环。
*/
```

# Defer延迟函数执行 Func_Defer (Function Defer)
### Defer语义：推迟、延迟
### 在Go语言中，使用Defer关键字来延迟一个函数活着方法的执行。
```go
package main

import "fmt"

func main() {
	f("1")
	fmt.Println("2")
	// 会被延迟到最后执行
	defer f("3")
	fmt.Println("4")
}

func f(s string) {
	fmt.Println(s)
}

```



### Defer函数或者方法：一个函数或方法的执行被延迟了
### 你可以在函数中添加多个defer语句，当函数执行到最后是，这些defer语句会按照逆序执行，最后该函数返回，特别是当你在进行一些打开资源的操作时，遇到错误需要提前返回，在返回前你需要关闭相应的资源，不然很容易造成资源泄露等问题
### 如果有很多调用defer，那么defer是采用后进先出模式，这与“栈”类似。



